name: Deploy VerveStacks Dashboard

on:
  push:
    branches: [ "main" ]
  workflow_dispatch: {}

env:
  # Flags
  Update_Data_On_Local: "true"
  Update_Data_On_Hetzner: "false"

  # NEW: control whether start.bat opens visible consoles
  # 'false' = run inline and check exit code (CI mode)
  # 'true'  = Start-Process -> separate window(s), no exit-code check
  SHOW_START_CONSOLES: "true"

  # Deployment roots
  DEPLOY_ROOT: "C:\\inetpub\\VerveStacks"
  DATA_ROOT: "C:\\inetpub\\VerveStacks\\data"

  # Local data source root (your main local data source)
  LOCAL_DATA_SOURCE_ROOT: "D:\\GitHub\\VerveStacks\\data"

  # Base UNC share (YAML-escaped; runtime value is \\192.168.0.7\kanvault)
  KANVAULT_SHARE: "\\\\192.168.0.7\\kanvault"

  # Destination data paths
  DEST_OSM: "C:\\inetpub\\VerveStacks\\data\\OSM-kan-prebuilt"
  DEST_TRANSMISSION: "C:\\inetpub\\VerveStacks\\data\\transmission_line_generation"
  DEST_ATLITE: "C:\\inetpub\\VerveStacks\\data\\Atlite_data_optimized"
  DEST_REZONING: "C:\\inetpub\\VerveStacks\\data\\REZoning_world_data"

  # Application subroot (beneath DEPLOY_ROOT)
  APP_SUBROOT: "vervestacks-dashboard"

  # Python service settings
  PYTHON_EXE: "C:\\Python312\\python.exe"

  # App source root (what you copy from)
  APP_SOURCE_ROOT: "D:\\GitHub\\VerveStacks\\vervestacks-dashboard"

  # Full repo root (what you asked to copy 1:1)
  REPO_SOURCE_ROOT: "D:\\GitHub\\VerveStacks"

jobs:
  deploy:
    runs-on: self-hosted

    steps:
      # =====================
      # CHECKOUT REPOSITORY
      # =====================
      - name: Checkout code
        uses: actions/checkout@v4

      # =====================
      # INIT WORKFLOW RUN LOG
      # =====================
      - name: Init workflow run log file
        shell: powershell
        run: |
          $stepName = 'Init workflow run log file'
          $logRoot = 'D:\GitHub\VerveStacks_Logs'

          $ErrorActionPreference = 'Stop'
          trap {
            Write-Host '### STEP FAILED: Init workflow run log file'
            Write-Host ('### ERROR: {0}' -f $_.Exception.Message)
            Write-Host $_.ScriptStackTrace
            exit 1
          }

          if (-not (Test-Path $logRoot)) {
            New-Item -ItemType Directory -Path $logRoot | Out-Null
          }

          $timestamp = Get-Date -Format 'yyyy-MM-ddTHH-mm-ss'
          # Simpler log file name: Deploy_<timestamp>.log
          $fileName  = "Deploy_$timestamp.log"
          # FIXED: regex char class (no double "")
          $safeName  = ($fileName -replace '[\\/:*?"<>|]', '_')
          $logFile   = Join-Path $logRoot $safeName

          'STEP     : Init workflow run log file' | Out-File -FilePath $logFile -Encoding UTF8
          ('Workflow : {0}' -f $env:GITHUB_WORKFLOW)   | Out-File -FilePath $logFile -Encoding UTF8 -Append
          ('Run ID   : {0}' -f $env:GITHUB_RUN_ID)     | Out-File -FilePath $logFile -Encoding UTF8 -Append
          ('Job      : {0}' -f $env:GITHUB_JOB)        | Out-File -FilePath $logFile -Encoding UTF8 -Append
          ('Repo     : {0}' -f $env:GITHUB_REPOSITORY) | Out-File -FilePath $logFile -Encoding UTF8 -Append
          ('Commit   : {0}' -f $env:GITHUB_SHA)        | Out-File -FilePath $logFile -Encoding UTF8 -Append
          ('Actor    : {0}' -f $env:GITHUB_ACTOR)      | Out-File -FilePath $logFile -Encoding UTF8 -Append
          ('Workspace: {0}' -f $env:GITHUB_WORKSPACE)  | Out-File -FilePath $logFile -Encoding UTF8 -Append
          ('Started  : {0}' -f (Get-Date -Format o))   | Out-File -FilePath $logFile -Encoding UTF8 -Append
          '--------------------------------------'     | Out-File -FilePath $logFile -Encoding UTF8 -Append

          "LOG_FILE=$logFile" | Out-File -FilePath $env:GITHUB_ENV -Encoding UTF8 -Append
          exit 0

      # =====================
      # MAP UNC SHARE (kanvault)
      # =====================
      - name: Map kanvault share
        if: env.Update_Data_On_Local == 'true'
        shell: powershell
        env:
          KANVAULT_PASSWORD: ${{ secrets.KANVAULT_PASSWORD }}
        run: |
          $stepName = 'Map kanvault share'
          $log = $env:LOG_FILE

          if ($log) { Start-Transcript -Path $log -Append | Out-Null }

          $ErrorActionPreference = 'Stop'
          trap {
            Write-Host ('### STEP FAILED: {0}' -f $stepName)
            Write-Host ('### ERROR: {0}' -f $_.Exception.Message)
            Write-Host $_.ScriptStackTrace
            if ($log) { Stop-Transcript | Out-Null }
            exit 1
          }

          Write-Host ('=== [{0}] ===' -f $stepName)
          Write-Host ("Mapping {0} with user 'amit'" -f $env:KANVAULT_SHARE)

          try {
            Write-Host 'Attempting to delete existing mapping...'
            net use $env:KANVAULT_SHARE /delete /y
          } catch {
            Write-Host 'No existing mapping or delete failed. Continuing.'
          }

          net use $env:KANVAULT_SHARE /user:amit $env:KANVAULT_PASSWORD
          if ($LASTEXITCODE -ne 0) {
            Write-Host ("### ERROR DETAIL: net use failed with exit code {0}." -f $LASTEXITCODE)
            if ($log) { Stop-Transcript | Out-Null }
            exit $LASTEXITCODE
          }

          Write-Host 'UNC network share mapped successfully.'

          if ($log) { Stop-Transcript | Out-Null }
          exit 0

      # ==========================================================
      # 1) ALL DATA SYNC (KANVAULT + LOCAL) IN ONE STEP
      # ==========================================================
      - name: Sync all data (kanvault + local) to IIS
        if: env.Update_Data_On_Local == 'true'
        shell: powershell
        run: |
          $stepName = 'Sync all data (kanvault + local) to IIS'
          $log = $env:LOG_FILE

          if ($log) { Start-Transcript -Path $log -Append | Out-Null }

          $ErrorActionPreference = 'Stop'
          trap {
            Write-Host ('### STEP FAILED: {0}' -f $stepName)
            Write-Host ('### ERROR: {0}' -f $_.Exception.Message)
            Write-Host $_.ScriptStackTrace
            if ($log) { Stop-Transcript | Out-Null }
            exit 1
          }

          Write-Host ('=== [{0}] ===' -f $stepName)

          $shareRoot = $env:KANVAULT_SHARE
          $verveRoot = Join-Path $shareRoot 'KanORS_Data\VerveStacks'
          $rezRoot   = Join-Path $shareRoot 'KanORS_Data\REZoning data'

          Write-Host ('VerveStacks UNC root = {0}' -f $verveRoot)
          Write-Host ('REZoning UNC root    = {0}' -f $rezRoot)

          $syncJobs = @(
            @{ Name = 'OSM-kan-prebuilt'
               Source = Join-Path $verveRoot 'OSM-kan-prebuilt'
               Dest   = $env:DEST_OSM },
            @{ Name = 'OSM-kan-prebuilt (harish)'
               Source = Join-Path $verveRoot 'OSM-kan-prebuilt\harish'
               Dest   = $env:DEST_OSM },
            @{ Name = 'transmission_line_generation'
               Source = Join-Path $verveRoot 'transmission_line_generation'
               Dest   = $env:DEST_TRANSMISSION },
            @{ Name = 'Atlite_data_optimized'
               Source = Join-Path $rezRoot 'Atlite_data\Atlite_data_optimized'
               Dest   = $env:DEST_ATLITE },
            @{ Name = 'REZoning_world_data'
               Source = Join-Path $rezRoot 'REZoning_world_data'
               Dest   = $env:DEST_REZONING }
          )

          $exitCodes = @()

          foreach ($job in $syncJobs) {
            $name   = $job.Name
            $source = $job.Source
            $dest   = $job.Dest

            Write-Host '----'
            Write-Host ("Job: {0}" -f $name)
            Write-Host ("  Source: {0}" -f $source)
            Write-Host ("  Dest  : {0}" -f $dest)

            if (-not (Test-Path $dest)) {
              Write-Host ("Creating destination folder: {0}" -f $dest)
              New-Item -ItemType Directory -Path $dest | Out-Null
            }

            if (-not (Test-Path $source)) {
              Write-Host ("WARNING: Source does not exist: {0}" -f $source)
              continue
            }

            Write-Host ("Starting robocopy for '{0}'..." -f $name)
            robocopy $source $dest /E /Z /R:3 /W:5 /ETA /NP
            $exitCodes += $LASTEXITCODE

            Write-Host ("Robocopy exit code: {0}" -f $LASTEXITCODE)
          }

          $maxCode = ($exitCodes | Measure-Object -Maximum).Maximum

          Write-Host ("Max robocopy code = {0}" -f $maxCode)
          Write-Host 'INFO: 0â€“7 success, 8+ failure'

          if ($maxCode -ge 8) {
            Write-Host '### ERROR DETAIL: One or more sync jobs failed.'
            if ($log) { Stop-Transcript | Out-Null }
            exit $maxCode
          }

          Write-Host 'All data sync jobs completed successfully.'

          if ($log) { Stop-Transcript | Out-Null }
          exit 0

      # ==========================================================
      # 1b) SYNC FULL VerveStacks FOLDER TO DEPLOY_ROOT
      # ==========================================================
      - name: Sync full VerveStacks repo to DEPLOY_ROOT
        if: env.Update_Data_On_Local == 'true'
        shell: powershell
        run: |
          $stepName = 'Sync full VerveStacks repo to DEPLOY_ROOT'
          $log = $env:LOG_FILE

          if ($log) { Start-Transcript -Path $log -Append | Out-Null }

          $ErrorActionPreference = 'Stop'
          trap {
            Write-Host ('### STEP FAILED: {0}' -f $stepName)
            Write-Host ('### ERROR: {0}' -f $_.Exception.Message)
            Write-Host $_.ScriptStackTrace
            if ($log) { Stop-Transcript | Out-Null }
            exit 1
          }

          Write-Host ('=== [{0}] ===' -f $stepName)

          $src = $env:REPO_SOURCE_ROOT
          $dst = $env:DEPLOY_ROOT

          Write-Host ("Source (REPO_SOURCE_ROOT) = {0}" -f $src)
          Write-Host ("Destination (DEPLOY_ROOT) = {0}" -f $dst)

          if (-not (Test-Path $src)) {
            Write-Host '### ERROR DETAIL: REPO_SOURCE_ROOT does not exist. Check D:\GitHub\VerveStacks.'
            if ($log) { Stop-Transcript | Out-Null }
            exit 1
          }

          if (-not (Test-Path $dst)) {
            Write-Host ("Creating DEPLOY_ROOT (with parents if needed): {0}" -f $dst)
            [System.IO.Directory]::CreateDirectory($dst) | Out-Null
          }

          Write-Host 'Running robocopy for FULL VerveStacks sync (excluding .git and .github folders)...'
          robocopy $src $dst /E /Z /R:3 /W:5 /XD ".git" ".github" /NFL /NDL /NJH /NJS /NP
          $code = $LASTEXITCODE

          Write-Host ("Full repo robocopy exit code: {0}" -f $code)
          Write-Host 'INFO: Robocopy exit codes 0-7 are success/acceptable; 8 or higher indicates failure.'

          if ($code -ge 8) {
            Write-Host ("### ERROR DETAIL: Full repo robocopy failed (code {0}). Files may be partially copied." -f $code)
            if ($log) { Stop-Transcript | Out-Null }
            exit $code
          }

          Write-Host 'Full VerveStacks repo sync to DEPLOY_ROOT completed successfully.'

          if ($log) { Stop-Transcript | Out-Null }
          exit 0

      # ==========================================================
      # 2) APP DEPLOY (COPY APP SOURCE TO DEPLOY_ROOT\APP_SUBROOT)
      # ==========================================================
      - name: Deploy app from APP_SOURCE_ROOT to DEPLOY_ROOT\APP_SUBROOT
        if: env.Update_Data_On_Local == 'true'
        shell: powershell
        run: |
          $stepName = 'Deploy app files to IIS folder'
          $log = $env:LOG_FILE

          if ($log) { Start-Transcript -Path $log -Append | Out-Null }

          $ErrorActionPreference = 'Stop'
          trap {
            Write-Host ('### STEP FAILED: {0}' -f $stepName)
            Write-Host ('### ERROR: {0}' -f $_.Exception.Message)
            Write-Host $_.ScriptStackTrace
            if ($log) { Stop-Transcript | Out-Null }
            exit 1
          }

          Write-Host ('=== [{0}] ===' -f $stepName)

          $src = $env:APP_SOURCE_ROOT
          $dst = Join-Path $env:DEPLOY_ROOT $env:APP_SUBROOT

          Write-Host ("Source (APP_SOURCE_ROOT) = {0}" -f $src)
          Write-Host ("Destination (DEPLOY_ROOT\APP_SUBROOT) = {0}" -f $dst)

          if (-not (Test-Path $src)) {
            Write-Host '### ERROR DETAIL: Source app folder does not exist. Check APP_SOURCE_ROOT.'
            if ($log) { Stop-Transcript | Out-Null }
            exit 1
          }

          if (-not (Test-Path $dst)) {
            Write-Host ("Creating deployment folder (with parents if needed): {0}" -f $dst)
            [System.IO.Directory]::CreateDirectory($dst) | Out-Null
          }

          Write-Host 'Running robocopy for application deployment (excluding .git & .github folders)...'
          robocopy $src $dst /E /Z /R:3 /W:5 /XD ".git" ".github" /NFL /NDL /NJH /NJS /NP
          $code = $LASTEXITCODE

          Write-Host ("App robocopy exit code: {0}" -f $code)
          Write-Host 'INFO: Robocopy exit codes 0-7 are success/acceptable; 8 or higher indicates failure.'

          if ($code -ge 8) {
            Write-Host ("### ERROR DETAIL: Deployment robocopy failed (code {0}). Files may be partially copied." -f $code)
            if ($log) { Stop-Transcript | Out-Null }
            exit $code
          }

          Write-Host 'Deployment completed successfully (app folder synced to IIS target).'

          if ($log) { Stop-Transcript | Out-Null }
          exit 0

      # ==========================================================
      # 3) BACKEND + FRONTEND (npm) ON DESTINATION
      # ==========================================================
      - name: Install JS deps and build frontend on DEPLOY_ROOT
        shell: powershell
        run: |
          $stepName = 'Install JS deps and build frontend'
          $log = $env:LOG_FILE

          if ($log) { Start-Transcript -Path $log -Append | Out-Null }

          $ErrorActionPreference = 'Stop'
          trap {
            Write-Host "### STEP FAILED: $stepName"
            Write-Host "### ERROR: $($_.Exception.Message)"
            Write-Host $_.ScriptStackTrace
            if ($log) { Stop-Transcript | Out-Null }
            exit 1
          }

          Write-Host "=== [$stepName] ==="

          $appRoot   = Join-Path $env:DEPLOY_ROOT $env:APP_SUBROOT
          $backend   = Join-Path $appRoot 'backend'
          $frontend  = Join-Path $appRoot 'frontend'

          $apps = @(
            @{ Name = 'Backend'; Path = $backend; Build = $false },
            @{ Name = 'Frontend'; Path = $frontend; Build = $true }
          )

          foreach ($a in $apps) {
            $name  = $a.Name
            $path  = $a.Path
            $build = $a.Build

            Write-Host '----'
            Write-Host ("{0}: Path = {1}" -f $name, $path)

            if (-not (Test-Path $path)) {
              if ($name -eq 'Backend') {
                Write-Host ("WARNING: {0} path does not exist: {1} - skipping backend npm install." -f $name, $path)
                continue
              }
              else {
                Write-Host ("ERROR: {0} path does not exist: {1}" -f $name, $path)
                if ($log) { Stop-Transcript | Out-Null }
                exit 1
              }
            }

            cd $path

            $nodeModules = Join-Path $path 'node_modules'
            if (Test-Path $nodeModules) {
              Write-Host ("{0}: Removing existing node_modules for a clean install..." -f $name)
              try {
                Remove-Item -Recurse -Force $nodeModules
              }
              catch {
                Write-Host ("ERROR: {0}: Failed to delete node_modules: {1}" -f $name, $_.Exception.Message)
                if ($log) { Stop-Transcript | Out-Null }
                exit 1
              }
            }

            Write-Host ("{0}: running npm install..." -f $name)
            npm install
            if ($LASTEXITCODE -ne 0) {
              Write-Host ("{0}: npm install failed with exit code {1}" -f $name, $LASTEXITCODE)
              if ($log) { Stop-Transcript | Out-Null }
              exit 1
            }

            if ($build) {
              Write-Host ("{0}: running build:prod with CI=false..." -f $name)
              $env:CI = 'false'
              npm run build:prod
              if ($LASTEXITCODE -ne 0) {
                Write-Host ("{0}: npm run build:prod failed with exit code {1}" -f $name, $LASTEXITCODE)
                if ($log) { Stop-Transcript | Out-Null }
                exit 1
              }
            }
          }

          if ($log) { Stop-Transcript | Out-Null }
          exit 0

      # ==========================================================
      # 3b) PUBLISH FRONTEND BUILD TO IIS ROOT
      # ==========================================================
      - name: Publish frontend build to IIS root
        shell: powershell
        run: |
          $stepName = 'Publish frontend build to IIS root'
          $log = $env:LOG_FILE

          if ($log) { Start-Transcript -Path $log -Append | Out-Null }

          $ErrorActionPreference = 'Stop'
          trap {
            Write-Host "### STEP FAILED: $stepName"
            Write-Host "### ERROR: $($_.Exception.Message)"
            Write-Host $_.ScriptStackTrace
            if ($log) { Stop-Transcript | Out-Null }
            exit 1
          }

          Write-Host "=== [$stepName] ==="

          $appRoot  = Join-Path $env:DEPLOY_ROOT $env:APP_SUBROOT
          $buildDir = Join-Path $appRoot 'frontend\build'

          Write-Host ("App root  = {0}" -f $appRoot)
          Write-Host ("Build dir = {0}" -f $buildDir)

          if (-not (Test-Path $buildDir)) {
            Write-Host '### ERROR DETAIL: Frontend build directory not found. React build probably failed.'
            if ($log) { Stop-Transcript | Out-Null }
            exit 1
          }

          robocopy $buildDir $appRoot /E /R:3 /W:5 /NFL /NDL /NJH /NJS /NP
          $code = $LASTEXITCODE

          Write-Host ("Robocopy exit code (publish build) = {0}" -f $code)
          Write-Host 'INFO: Robocopy exit codes 0-7 are success/acceptable; 8 or higher indicates failure.'

          if ($code -ge 8) {
            Write-Host ("### ERROR DETAIL: Failed to publish frontend build to IIS root (code {0})." -f $code)
            if ($log) { Stop-Transcript | Out-Null }
            exit $code
          }

          Write-Host 'Frontend build published to IIS root successfully.'

          if ($log) { Stop-Transcript | Out-Null }
          exit 0

      # ==========================================================
      # 4) PYTHON SERVICE SETUP
      # ==========================================================
      - name: Setup python service on deployed folder
        shell: powershell
        run: |
          $stepName = 'Setup python service'
          $log = $env:LOG_FILE

          if ($log) { Start-Transcript -Path $log -Append | Out-Null }

          $ErrorActionPreference = 'Stop'
          trap {
            Write-Host "### STEP FAILED: $stepName"
            Write-Host "### ERROR: $($_.Exception.Message)"
            Write-Host $_.ScriptStackTrace
            if ($log) { Stop-Transcript | Out-Null }
            exit 1
          }

          Write-Host "=== [$stepName] ==="

          $appRoot    = Join-Path $env:DEPLOY_ROOT $env:APP_SUBROOT
          $pythonPath = Join-Path $appRoot 'python-service'

          Write-Host ("Python service path = {0}" -f $pythonPath)
          Write-Host ("PYTHON_EXE         = {0}" -f $env:PYTHON_EXE)

          if (-not (Test-Path $pythonPath)) {
            Write-Host '### ERROR DETAIL: python-service folder not found under app root.'
            if ($log) { Stop-Transcript | Out-Null }
            exit 1
          }

          cd $pythonPath

          if (-not (Test-Path '.venv')) {
            Write-Host 'Creating virtual environment in .venv...'
            & $env:PYTHON_EXE -m venv .venv
          }
          else {
            Write-Host 'Virtual environment .venv already exists, reusing it.'
          }

          .\.venv\Scripts\python.exe -m pip install --upgrade pip
          .\.venv\Scripts\python.exe -m pip install -r requirements.txt

          if ($log) { Stop-Transcript | Out-Null }
          exit 0

      # ==========================================================
      # 4b) RUN DATABASE SETUP (setup_database_ci.bat)
      # ==========================================================
      - name: Run database setup (setup_database_ci.bat)
        shell: powershell
        env:
          DB_PASSWORD: ${{ secrets.VERVESTACKS_DB_PASSWORD }}
        run: |
          $stepName = 'Run database setup (setup_database.bat)'
          $log = $env:LOG_FILE

          if ($log) { Start-Transcript -Path $log -Append | Out-Null }

          $ErrorActionPreference = 'Stop'
          trap {
            Write-Host "### STEP FAILED: $stepName"
            Write-Host "### ERROR: $($_.Exception.Message)"
            Write-Host $_.ScriptStackTrace
            if ($log) { Stop-Transcript | Out-Null }
            exit 1
          }

          Write-Host "=== [$stepName] ==="

          $appRoot  = Join-Path $env:DEPLOY_ROOT $env:APP_SUBROOT
          $dbPath   = Join-Path $appRoot 'backend\database'
          $batPath  = Join-Path $dbPath 'setup_database.bat'

          Write-Host ("DB folder path      = {0}" -f $dbPath)
          Write-Host ("DB setup batch path = {0}" -f $batPath)

          if (-not (Test-Path $dbPath)) {
            Write-Host '### ERROR DETAIL: Database folder not found under backend\database.'
            if ($log) { Stop-Transcript | Out-Null }
            exit 1
          }

          if (-not (Test-Path $batPath)) {
            Write-Host '### ERROR DETAIL: setup_database.bat not found.'
            if ($log) { Stop-Transcript | Out-Null }
            exit 1
          }

          if ([string]::IsNullOrWhiteSpace($env:DB_PASSWORD)) {
            Write-Host '### ERROR DETAIL: DB_PASSWORD environment variable is empty. Set secrets.VERVESTACKS_DB_PASSWORD in GitHub.'
            if ($log) { Stop-Transcript | Out-Null }
            exit 1
          }

          Write-Host 'Running database setup batch (CI mode)...'
          cd $dbPath

          # Pass password as first argument (adjust if your script expects differently)
          & $batPath $env:DB_PASSWORD
          $code = $LASTEXITCODE

          Write-Host ("Database setup batch exit code = {0}" -f $code)

          if ($code -ne 0) {
            Write-Host ("### ERROR DETAIL: Database setup failed (exit code {0}). Check batch output above." -f $code)
            if ($log) { Stop-Transcript | Out-Null }
            exit $code
          }

          Write-Host 'Database setup completed successfully.'

          if ($log) { Stop-Transcript | Out-Null }
          exit 0

      # ==========================================================
      # 5) PLACEHOLDER: HETZNER DEPLOY (FUTURE)
      # ==========================================================
      - name: Deploy to Hetzner (placeholder)
        if: env.Update_Data_On_Hetzner == 'true'
        shell: powershell
        run: |
          $stepName = 'Deploy to Hetzner (placeholder)'
          $log = $env:LOG_FILE
          if ($log) { Start-Transcript -Path $log -Append | Out-Null }
          $ErrorActionPreference = 'Stop'
          trap {
            Write-Host "### STEP FAILED: $stepName"
            Write-Host "### ERROR: $($_.Exception.Message)"
            Write-Host $_.ScriptStackTrace
            if ($log) { Stop-Transcript | Out-Null }
            exit 1
          }
          Write-Host "=== [$stepName] ==="
          Write-Host 'Update_Data_On_Hetzner == true, but remote deploy logic is not implemented yet.'
          if ($log) { Stop-Transcript | Out-Null }
          exit 0

      # ==========================================================
      # 6) RUN start.bat AFTER DEPLOYMENT (NON-BLOCKING WHEN CONSOLES SHOWN)
      # ==========================================================
      - name: Run start.bat after deployment
        if: env.Update_Data_On_Local == 'true'
        shell: powershell
        run: |
          $stepName = 'Run start.bat'
          $log = $env:LOG_FILE

          if ($log) { Start-Transcript -Path $log -Append | Out-Null }

          $ErrorActionPreference = 'Stop'
          trap {
            Write-Host "### STEP FAILED: $stepName"
            Write-Host "### ERROR: $($_.Exception.Message)"
            Write-Host $_.ScriptStackTrace
            if ($log) { Stop-Transcript | Out-Null }
            exit 1
          }

          Write-Host "=== [$stepName] ==="

          # Path to start.bat in deployed folder
          $scriptPath = Join-Path $env:DEPLOY_ROOT "$env:APP_SUBROOT\start.bat"
          $showConsoles = $env:SHOW_START_CONSOLES

          Write-Host ("Expected start.bat path: {0}" -f $scriptPath)
          Write-Host ("SHOW_START_CONSOLES   : {0}" -f $showConsoles)

          if (-not (Test-Path $scriptPath)) {
            Write-Host '### ERROR DETAIL: start.bat not found. Check that it exists in the app root.'
            if ($log) { Stop-Transcript | Out-Null }
            exit 1
          }

          if ($showConsoles -eq 'true') {
            Write-Host 'SHOW_START_CONSOLES == true, launching start.bat in a separate window and NOT waiting for it.'

            # Launch start.bat via cmd.exe in a separate window. Do NOT wait.
            $cmdArgs = "/c `"`"$scriptPath`"`""
            Start-Process -FilePath "cmd.exe" -ArgumentList $cmdArgs -WindowStyle Normal | Out-Null

            if ($log) { Stop-Transcript | Out-Null }
            exit 0
          }
          else {
            Write-Host 'SHOW_START_CONSOLES != true, running start.bat inline and waiting for it to finish.'
            & $scriptPath
            $rc = $LASTEXITCODE

            if ($rc -ne 0) {
              Write-Host ("### ERROR DETAIL: start.bat exited with code {0}. See any messages printed by the script above." -f $rc)
              if ($log) { Stop-Transcript | Out-Null }
              exit $rc
            }

            Write-Host "start.bat completed successfully."
            if ($log) { Stop-Transcript | Out-Null }
            exit 0
          }